Index: .env.example
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>PORT=3000\n\n# FRONTEND INFORMATION\nFRONTEND_BASE_URL=http://localhost:8080/\n\n# DB\nDB_CLUSTER=\n\n# Secrets or rather randomString\nAUTH_TOKEN_SECRET=\nREFRESH_TOKEN_SECRET=\n\n# Transactional emails\nBREVO_PASSWORD=\nBREVO_EMAIL=\n\nSEND_TRANSACTIONAL_EMAILS_FROM_EMAIL=verification@groupera.de\nSEND_TRANSACTIONAL_EMAILS_FROM_NAME=Marie\n\n# Cloudinary\nCLOUDINARY_NAME=\nCLOUDINARY_KEY=\nCLOUDINARY_SECRET=\n\n# Google Calendar\nCALENDAR_KEY=\nCREDENTIALS=\nCALENDAR_ID=\n\n# Video SDK\nVIDEO_KEY=\nVIDEO_SECRET=\nVIDEOSDK_API_ENDPOINT=\n\n# Stripe\nSTRIPE_PUBLIC=\nSTRIPE_SECRET=
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.env.example b/.env.example
--- a/.env.example	(revision 2c29de73265de7674881631128623c35c5fac3fb)
+++ b/.env.example	(date 1702032482333)
@@ -1,5 +1,8 @@
 PORT=3000
 
+# Can be development, test, staging, production (default: development)
+NODE_ENV=
+
 # FRONTEND INFORMATION
 FRONTEND_BASE_URL=http://localhost:8080/
 
Index: controllers/authControllers.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const bcrypt = require('bcryptjs')\nconst jwt = require('jsonwebtoken')\nconst { v4: uuidv4 } = require('uuid')\n\nconst { User } = require('../models/User.model')\n\nconst myCustomError = require('../utils/myCustomError')\n// const sendEmail = require('../utils/sendEmail')\nconst {\n\tcalcExpirationDate,\n\ttokenExpired,\n\tgetAuthTokens,\n\tcookieOptions,\n} = require('../utils/auth.helpers')\nconst {Group} = require('../models/Group.model');\n\n// const emailTemplates = require('../lib/emailTemplates')\n\nconst hashSomething = async (thingToHash) => {\n\tconst salt = await bcrypt.genSalt(Number(process.env.SALT))\n\n\treturn bcrypt.hash(thingToHash, salt)\n}\n\nexports.hashSomething = hashSomething\n\nexports.signup = async (req, res, next) => {\n\tconst { email, password } = req.body\n\n\ttry {\n\t\tconst randomCode = Math.floor(1000 + Math.random() * 9000).toString()\n\t\tconsole.log(randomCode)\n\t\tconst hashPassword = await hashSomething(password)\n\t\tconst hashCode = await hashSomething(randomCode)\n\n\t\tconst user = await new User({\n\t\t\t...req.body,\n\t\t\temail: email.toLowerCase(),\n\t\t\tpasswordHash: hashPassword,\n\t\t\tauthCode: hashCode,\n\t\t}).save()\n\n\t\tres.locals.user = user\n\t\tres.locals.authCode = randomCode\n\t\tnext()\n\t} catch (error) {\n\t\tnext(error)\n\t}\n}\n\nexports.verifyEmail = async (req, res, next) => {\n\tconst {\n\t\tbody: { authCode, email, joinedGroups },\n\t} = req\n\ttry {\n\t\tlet user = await User.findOne({ email: email })\n\t\tif (!user) throw myCustomError('Ungültiger Email', 401)\n\n\t\tconst validAuthCode = await bcrypt.compare(authCode, user.authCode)\n\t\tif (!validAuthCode) throw myCustomError('Incorrect code!', 401)\n\n\t\tuser.emailVerified = true\n\t\tuser.emailVerificationExpires = null\n\t\tuser.authCode = ''\n\n\t\tif (joinedGroups && joinedGroups[0]) {\n\t\t\tconst group = await Group.findById(joinedGroups[0])\n\t\t\tif (group) {\n\t\t\t\tgroup.members.push(user.id)\n\t\t\t\tawait group.save()\n\n\t\t\t\tuser.joinedGroups.push(joinedGroups[0])\n\t\t\t}\n\t\t}\n\n\t\tconst { userObject, authToken, refreshToken } = getAuthTokens(user)\n\n\t\tawait user.save()\n\n\t\t// should I send the Mongo formatted ID as the user ID or just the string?!\n\n\t\t// I had the same question, actually. Is mongo formatted better practice?\n\t\tres.cookie('refreshToken', refreshToken, cookieOptions).send({\n\t\t\tauthToken,\n\t\t\tuser: userObject,\n\t\t\tmessage: 'Bentzer erfolgreich verfiziert',\n\t\t})\n\t} catch (error) {\n\t\tnext(error)\n\t}\n}\n\nexports.resendEmailVerification = async (req, res, next) => {\n\tconst { email } = req.params\n\ttry {\n\t\tlet user = await User.findOne({ email: email.toLowerCase() })\n\t\tif (!user) throw myCustomError('Ungültiger Email', 401)\n\n\t\tconst randomCode = Math.floor(1000 + Math.random() * 9000).toString()\n\t\tconsole.log(randomCode)\n\t\tconst hashCode = await hashSomething(randomCode)\n\n\t\tuser.authCode = hashCode\n\t\tawait user.save()\n\n\t\tres.locals.user = user\n\t\tres.locals.authCode = randomCode\n\t\tnext()\n\t} catch (error) {\n\t\tnext(error)\n\t}\n}\n\nexports.login = async (req, res, next) => {\n\ttry {\n\t\tconst { email, password } = req.body\n\n\t\tconst user = await User.findOne({ email: email.toLowerCase() }, '+passwordHash')\n\t\tif (!user) throw myCustomError('Ungültige E-Mail oder Passwort', 401)\n\n\t\tconst validPassword = await bcrypt.compare(password, user.passwordHash)\n\t\tif (!validPassword)\n\t\t\tthrow myCustomError('Ungültige E-Mail oder Passwort', 401)\n\n\t\tif (!user.emailVerified)\n\t\t\tthrow myCustomError(\n\t\t\t\t'Bitte bestätigen Sie Ihre E-Mail Addresse',\n\t\t\t\t400\n\t\t\t)\n\n\t\tconst { userObject, authToken, refreshToken } = getAuthTokens(user)\n\n\t\t// should I send the Mongo formatted ID as the user ID or just the string?!\n\t\tres.cookie('refreshToken', refreshToken, cookieOptions).send({\n\t\t\tauthToken,\n\t\t\tuser: userObject,\n\t\t\tmessage: 'Erfolgreich eingeloggt',\n\t\t})\n\t} catch (error) {\n\t\tnext(error)\n\t}\n}\n\nexports.setResetPasswordToken = async (req, res, next) => {\n\tconst { email } = req.body\n\ttry {\n\t\tlet user = await User.findOne({ email: email.toLowerCase() })\n\t\t// As security measure we respond always with status code of 200 and the same message\n\t\tif (!user)\n\t\t\tthrow myCustomError(\n\t\t\t\t'Der Link zum Zurücksetzen des Passworts wurde an Ihre E-Mail-Adresse gesendet',\n\t\t\t\t200\n\t\t\t)\n\n\t\tuser.resetPasswordToken = uuidv4()\n\t\tuser.resetPasswordTokenExp = calcExpirationDate('ResetPasswordToken')\n\n\t\tawait user.save()\n\n\t\tconst url = `${process.env.FRONTEND_BASE_URL}/auth/resetPassword/${user.resetPasswordToken}`\n\n\t\tres.locals.user = user\n\t\tres.locals.resetPasswordToken = user.resetPasswordToken\n\t\tres.locals.resetPasswordTokenExp = user.resetPasswordTokenExp\n\t\tres.locals.url = url\n\n\t\tnext()\n\t} catch (error) {\n\t\tnext(error)\n\t}\n}\n\nexports.resetPassword = async (req, res, next) => {\n\ttry {\n\t\tconst {\n\t\t\tbody: { password },\n\t\t\tparams: { resetPasswordToken },\n\t\t} = req\n\n\t\tconst user = await User.findOne({ resetPasswordToken })\n\t\tif (\n\t\t\t!user ||\n\t\t\t!user.resetPasswordTokenExp ||\n\t\t\ttokenExpired(user.resetPasswordTokenExp)\n\t\t)\n\t\t\tthrow myCustomError('Invalid Token', 400)\n\n\t\tconst salt = await bcrypt.genSalt(Number(process.env.SALT))\n\t\tconst hashPassword = await bcrypt.hash(password, salt)\n\n\t\tuser.resetPasswordTokenExp = undefined\n\t\tuser.resetPasswordToken = undefined\n\t\tuser.password = hashPassword\n\t\tawait user.save()\n\n\t\tconst { userObject, authToken, refreshToken } = getAuthTokens(user)\n\t\t// should I send the Mongo formatted ID as the user ID or just the string?!\n\t\tres.cookie('refreshToken', refreshToken, cookieOptions).send({\n\t\t\tauthToken,\n\t\t\tuser: userObject,\n\t\t\tmessage: 'Passwort erfolgreich zurückgesetzt.',\n\t\t})\n\t} catch (error) {\n\t\tnext(error)\n\t}\n}\n\nexports.logout = async (req, res, next) => {\n\ttry {\n\t\tres.cookie('refreshToken', '')\n\t\t\t.clearCookie('refreshToken', {\n\t\t\t\thttpOnly: true,\n\t\t\t\tsameSite: 'None',\n\t\t\t\tsecure: true,\n\t\t\t})\n\t\t\t.sendStatus(204)\n\t} catch (error) {\n\t\tnext(error)\n\t}\n}\n\n// Ask Fritz about using != and keeping foundUser._id like in Middleware versus using !== with toString()\nexports.refresh = async (req, res, next) => {\n\ttry {\n\t\tconst { refreshToken: currentRefreshToken } = req.cookies\n\t\tjwt.verify(\n\t\t\tcurrentRefreshToken,\n\t\t\tprocess.env.REFRESH_TOKEN_SECRET,\n\t\t\t(err, decoded) => {\n\t\t\t\tif (err) throw myCustomError('Invalid Token', 400)\n\n\t\t\t\tconst {\n\t\t\t\t\tauthToken: newAuthToken,\n\t\t\t\t\trefreshToken: newRefreshToken,\n\t\t\t\t} = getAuthTokens(decoded.user)\n\n\t\t\t\tres.cookie('refreshToken', newRefreshToken, cookieOptions).send(\n\t\t\t\t\t{\n\t\t\t\t\t\tauthToken: newAuthToken,\n\t\t\t\t\t\tuser: decoded.user,\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t} catch (error) {\n\t\tnext(error)\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/controllers/authControllers.js b/controllers/authControllers.js
--- a/controllers/authControllers.js	(revision 2c29de73265de7674881631128623c35c5fac3fb)
+++ b/controllers/authControllers.js	(date 1702033340213)
@@ -29,7 +29,6 @@
 
 	try {
 		const randomCode = Math.floor(1000 + Math.random() * 9000).toString()
-		console.log(randomCode)
 		const hashPassword = await hashSomething(password)
 		const hashCode = await hashSomething(randomCode)
 
@@ -42,7 +41,13 @@
 
 		res.locals.user = user
 		res.locals.authCode = randomCode
-		next()
+		
+		if (process.env.NODE_ENV === 'development') {
+			console.log('Email Auth Code', randomCode)
+			res.sendStatus(204)
+		} else{
+			next()
+		}
 	} catch (error) {
 		next(error)
 	}
@@ -105,7 +110,13 @@
 
 		res.locals.user = user
 		res.locals.authCode = randomCode
-		next()
+
+		if (process.env.NODE_ENV === 'development') {
+			console.log('Email Auth Code', randomCode)
+			res.sendStatus(204)
+		} else{
+			next()
+		}
 	} catch (error) {
 		next(error)
 	}
@@ -164,7 +175,12 @@
 		res.locals.resetPasswordTokenExp = user.resetPasswordTokenExp
 		res.locals.url = url
 
-		next()
+		if (process.env.NODE_ENV === 'development') {
+			console.log('Email Auth Code', user.resetPasswordToken)
+			res.sendStatus(204)
+		} else{
+			next()
+		}
 	} catch (error) {
 		next(error)
 	}
